<!DOCTYPE html>
<html>
<head>
    <title>Excalidraw for Box</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        #app { 
            height: 100vh; 
            width: 100vw;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        .loading { 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            font-family: sans-serif;
            gap: 10px;
        }
        .loading small {
            color: #666;
            font-size: 14px;
        }
        .error {
            color: #d32f2f;
            background: #ffebee;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ffcdd2;
            max-width: 600px;
            text-align: center;
        }
    </style>
    
    <!-- Excalidraw CSS -->
    <link
      rel="stylesheet"
      href="https://esm.sh/@excalidraw/excalidraw@0.18.0/dist/dev/index.css"
    />
    
    <!-- Set asset path for Excalidraw -->
    <script>
        window.EXCALIDRAW_ASSET_PATH = "https://esm.sh/@excalidraw/excalidraw@0.18.0/dist/prod/";
    </script>
    
    <!-- Import map for module resolution -->
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.0.0",
          "react/jsx-runtime": "https://esm.sh/react@19.0.0/jsx-runtime",
          "react-dom": "https://esm.sh/react-dom@19.0.0"
          }
      }
    </script>
</head>
<body>
    <div id="app">
        <div class="loading">
            Loading Excalidraw for Box...<br/>
            <small>Initializing...</small>
        </div>
    </div>
    
    <script type="module">
        import * as ExcalidrawLib from 'https://esm.sh/@excalidraw/excalidraw@0.18.0/dist/dev/index.js?external=react,react-dom';
        import React from "https://esm.sh/react@19.0.0";
        import ReactDOM from "https://esm.sh/react-dom@19.0.0";
        import { createRoot } from 'https://esm.sh/react-dom@19.0.0/client';

        window.ExcalidrawLib = ExcalidrawLib;
        console.log("Excalidraw library", ExcalidrawLib);

        // Get parameters from URL
        const params = new URLSearchParams(window.location.search);
        const authCode = params.get('authCode');
        const fileId = params.get('fileId');
        
        console.log('Initial params:', { authCode, fileId });
        
        // Configuration variables
        let BOX_CLIENT_ID = '';
        let BOX_CLIENT_SECRET = '';
        
        async function loadCredentials() {
            try {
                const response = await fetch('./credentials.json');
                if (!response.ok) {
                    throw new Error(`Credentials not found: ${response.status}`);
                }
                const config = await response.json();
                BOX_CLIENT_ID = config.BOX_CLIENT_ID;
                BOX_CLIENT_SECRET = config.BOX_CLIENT_SECRET;
                
                if (!BOX_CLIENT_ID || !BOX_CLIENT_SECRET) {
                    throw new Error('Missing credentials in credentials.json');
                }
                
                console.log('Credentials loaded successfully');
                return true;
            } catch (error) {
                console.error('Failed to load credentials:', error);
                throw new Error(`Credentials error: ${error.message}`);
            }
        }

        async function checkFilePermissions(fileId, token) {
            try {
                console.log('Checking file permissions:', fileId);
                const response = await fetch(`https://api.box.com/2.0/files/${fileId}?fields=permissions`, {
                    headers: { 
                        'Authorization': `Bearer ${token}` 
                    }
                });
                
                if (!response.ok) {
                    console.warn(`Failed to get file info: ${response.status}`);
                    return true; // Default to writable if we can't check
                }
                
                const fileInfo = await response.json();
                const canUpload = fileInfo.permissions && fileInfo.permissions.can_upload;
                console.log('File permissions - can_upload:', canUpload);
                return canUpload;
            } catch (error) {
                console.error('Error checking file permissions:', error);
                return true; // Default to writable if we can't check
            }
        }

        // Helper functions for file serialization
        async function serializeFiles(files) {
            const serializedFiles = {};
            
            for (const [fileId, file] of Object.entries(files || {})) {
                if (file.dataURL) {
                    serializedFiles[fileId] = {
                        ...file,
                        dataURL: file.dataURL
                    };
                } else if (file instanceof File || file instanceof Blob) {
                    const dataURL = await blobToDataURL(file);
                    serializedFiles[fileId] = {
                        id: file.id || fileId,
                        dataURL: dataURL,
                        mimeType: file.type,
                        created: file.created || Date.now()
                    };
                } else {
                    serializedFiles[fileId] = file;
                }
            }
            
            return serializedFiles;
        }
        
        function deserializeFiles(serializedFiles) {
            const files = {};
            
            for (const [fileId, fileData] of Object.entries(serializedFiles || {})) {
                if (fileData.dataURL) {
                    files[fileId] = {
                        id: fileData.id || fileId,
                        dataURL: fileData.dataURL,
                        mimeType: fileData.mimeType,
                        created: fileData.created,
                        lastRetrieved: Date.now()
                    };
                }
            }
            
            return files;
        }
        
        function blobToDataURL(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        async function exchangeCodeForToken(code) {
            try {
                console.log('Exchanging code for token:', code);
                
                const response = await fetch('https://api.box.com/oauth2/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        grant_type: 'authorization_code',
                        code: code,
                        client_id: BOX_CLIENT_ID,
                        client_secret: BOX_CLIENT_SECRET
                    })
                });
                
                const responseText = await response.text();
                console.log('Token Response:', responseText);
                
                if (!response.ok) {
                    throw new Error(`Failed to exchange code for token: ${responseText}`);
                }
                
                const data = JSON.parse(responseText);
                
                // Clean up URL
                const cleanUrl = new URL(window.location);
                cleanUrl.searchParams.delete('authCode');
                window.history.replaceState({}, document.title, cleanUrl);
                
                return data.access_token;
            } catch (error) {
                console.error('Auth error:', error);
                throw error;
            }
        }
        
        async function loadFileFromBox(fileId, token) {
            try {
                console.log('Loading file:', fileId);
                const response = await fetch(`https://api.box.com/2.0/files/${fileId}/content`, {
                    headers: { 
                        'Authorization': `Bearer ${token}` 
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('File not found, will create new');
                        return null;
                    }
                    throw new Error(`Failed to load file: ${response.status}`);
                }
                
                const text = await response.text();
                try {
                    const data = JSON.parse(text);
                    // Deserialize files if they exist
                    if (data.files) {
                        data.files = deserializeFiles(data.files);
                    }
                    return data;
                } catch (parseError) {
                    console.log('File is not JSON, creating new drawing');
                    return null;
                }
            } catch (err) {
                console.error('Error loading file:', err);
                return null;
            }
        }
        
        async function saveFileToBox(fileId, token, data) {
            try {
                console.log('Saving to Box...');
                
                // Serialize files before saving
                const dataToSave = {
                    ...data,
                    files: await serializeFiles(data.files || {})
                };
                
                const formData = new FormData();
                const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { 
                    type: 'application/json' 
                });
                formData.append('file', blob, 'drawing.excalidraw');
                
                const response = await fetch(`https://upload.box.com/api/2.0/files/${fileId}/content`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Save failed:', response.status, errorText);
                    throw new Error(`Save failed: ${response.status}`);
                }
                
                console.log('Saved to Box successfully');
                return true;
            } catch (error) {
                console.error('Error saving:', error);
                return false;
            }
        }

        const App = () => {
            const [initialData, setInitialData] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const [accessToken, setAccessToken] = React.useState(null);
            const [loadingStage, setLoadingStage] = React.useState('Initializing...');
            const [isReadOnly, setIsReadOnly] = React.useState(false);
            const saveTimeoutRef = React.useRef(null);
            const maxSaveTimeoutRef = React.useRef(null);
            const lastSceneVersionRef = React.useRef(null);
            const excalidrawAPIRef = React.useRef(null);
            
            React.useEffect(() => {
                async function init() {
                    try {
                        setLoadingStage('Loading credentials...');
                        
                        // Load credentials first
                        await loadCredentials();
                        
                        setLoadingStage('Authenticating with Box...');
                        
                        // Must have auth code to proceed
                        if (!authCode) {
                            throw new Error('No authorization code. Please launch from Box.');
                        }
                        
                        setLoadingStage('Exchanging auth code for token...');
                        
                        // Exchange auth code for token
                        const token = await exchangeCodeForToken(authCode);
                        if (!token) {
                            throw new Error('Failed to authenticate with Box');
                        }
                        
                        console.log('Got access token');
                        setAccessToken(token);
                        setLoadingStage('Checking file permissions...');
                        
                        // Check if user can upload to this file
                        let canUpload = true;
                        if (fileId) {
                            canUpload = await checkFilePermissions(fileId, token);
                            setIsReadOnly(!canUpload);
                        }
                        
                        setLoadingStage('Loading file...');
                        
                        // Load file from Box if we have a file ID
                        let fileData = null;
                        if (fileId) {
                            fileData = await loadFileFromBox(fileId, token);
                            if (fileData) {
                                console.log('File loaded:', fileData);
                                setInitialData(fileData);
                                // Initialize scene version if available
                                if (fileData.elements && ExcalidrawLib.getSceneVersion) {
                                    lastSceneVersionRef.current = ExcalidrawLib.getSceneVersion(fileData.elements);
                                }
                            }
                        }
                        
                        setLoadingStage('Ready!');
                        console.log('Init complete - Read-only mode:', !canUpload);
                        setLoading(false);
                        
                    } catch (err) {
                        console.error('Initialization error:', err);
                        setError(err.message);
                        setLoading(false);
                    }
                }
                
                init();
            }, []);
            
            // Show read-only notification when API is ready
            React.useEffect(() => {
                if (excalidrawAPIRef.current && isReadOnly) {
                    excalidrawAPIRef.current.setToast({
                        message: "File is read-only - viewing mode only",
                        duration: 5000,
                        closable: true
                    });
                }
            }, [isReadOnly]);

            const handleChange = React.useCallback((elements, appState, files) => {
                if (!fileId || !accessToken || isReadOnly) return;
                
                // Only save on actual drawing changes, not cursor/viewport changes
                if (appState.isLoading || appState.isResizing) return;
                
                // Use scene version to detect meaningful changes
                const currentSceneVersion = ExcalidrawLib.getSceneVersion ? 
                    ExcalidrawLib.getSceneVersion(elements) : 
                    elements.length; // fallback to element count
                
                // Skip if no meaningful change detected
                if (currentSceneVersion === lastSceneVersionRef.current) {
                    return;
                }

                if (saveTimeoutRef.current || maxSaveTimeoutRef.current) {
                    return;
                }

                //console.log('Scene version changed:', lastSceneVersionRef.current, '->', currentSceneVersion);

                // Show toast if API is available
                if (excalidrawAPIRef.current) {
                    excalidrawAPIRef.current.setToast({ message: "Changes detected..." });
                }
                
                // Set up 60-second max timeout if not already running
                if (!maxSaveTimeoutRef.current) {
                    console.log('Starting 60-second max timer');
                    maxSaveTimeoutRef.current = setTimeout(async () => {
                        console.log('60-second max timer triggered');
                        await performSave(elements, appState, files);
                        if (saveTimeoutRef.current) {
                            clearTimeout(saveTimeoutRef.current);
                            saveTimeoutRef.current = null;
                        }
                        maxSaveTimeoutRef.current = null;
                    }, 60000); // 60 seconds max
                }

                // Clear existing 5-second timeout
                clearTimeout(saveTimeoutRef.current);
                
                // Set up 5-second inactivity timeout
                saveTimeoutRef.current = setTimeout(async () => {
                    console.log('5-second inactivity timer triggered');
                    await performSave(elements, appState, files);
                    saveTimeoutRef.current = null;
                    clearTimeout(maxSaveTimeoutRef.current);
                    maxSaveTimeoutRef.current = null;
                }, 5000); // 5 seconds after last change
                
                async function performSave(elements, appState, files) {
                    // Show saving toast
                    if (excalidrawAPIRef.current) {
                        excalidrawAPIRef.current.setToast({ message: "Saving to Box..." });
                    }
                    
                    const data = {
                        type: 'excalidraw',
                        version: 2,
                        elements,
                        appState,
                        files
                    };
                    
                    const success = await saveFileToBox(fileId, accessToken, data);
                    
                    // Show result toast
                    if (excalidrawAPIRef.current) {
                        excalidrawAPIRef.current.setToast({ 
                            message: success ? "Saved to Box!" : "Save failed",
                            closable: true,
                            duration: 3000
                        });
                    }
                    
                    // Update the last scene version
                    lastSceneVersionRef.current = ExcalidrawLib.getSceneVersion ? 
                        ExcalidrawLib.getSceneVersion(elements) : 
                        elements.length;
                }
            }, [fileId, accessToken]);

            if (loading) {
                return React.createElement('div', { className: 'loading' }, [
                    'Loading Excalidraw for Box...',
                    React.createElement('br', { key: 'br' }),
                    React.createElement('small', { key: 'status' }, loadingStage)
                ]);
            }
            
            if (error) {
                return React.createElement('div', { className: 'loading' }, 
                    React.createElement('div', { className: 'error' }, [
                        React.createElement('strong', { key: 'title' }, 'Error'),
                        React.createElement('br', { key: 'br' }),
                        error
                    ])
                );
            }

            const excalidrawProps = {
                onChange: isReadOnly ? undefined : handleChange, // No onChange handler if read-only
                excalidrawAPI: (api) => {
                    excalidrawAPIRef.current = api;
                    console.log('Excalidraw API available:', api);
                },
                viewModeEnabled: isReadOnly, // Enable read-only view mode
                isCollaborating: false,
                style: { height: "100vh" }
            };
            
            if (initialData) {
                excalidrawProps.initialData = initialData;
            }

            return React.createElement(
                React.Fragment,
                null,
                React.createElement(
                    "div",
                    { style: { position: 'relative', height: "100vh" } },
                    React.createElement(ExcalidrawLib.Excalidraw, excalidrawProps)
                )
            );
        };

        const excalidrawWrapper = document.getElementById("app");
        const root = createRoot(excalidrawWrapper);
        root.render(React.createElement(App));
    </script>
</body>
</html>